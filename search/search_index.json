{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to CDM Documentation!","text":""},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#msk_cdm.minio._minio_api.MinioAPI","title":"<code>MinioAPI</code>","text":"<p>             Bases: <code>object</code></p> <p>Object to simplify reading/writing to/from Minio.</p> Source code in <code>msk_cdm/minio/_minio_api.py</code> <pre><code>class MinioAPI(object):\n    \"\"\"Object to simplify reading/writing to/from Minio.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        ACCESS_KEY: Optional[str] = None,\n        SECRET_KEY: Optional[str] = None,\n        ca_certs: Optional[str] = None,\n        url_port: Optional[str] = \"tllihpcmind6:9000\",\n        fname_minio_env: Optional[Union[Path, str]] = None,\n    ):\n        \"\"\"Initialization\n\n        Args:\n            - ACCESS_KEY: Minio access key. Optional if `fname_minio_env` is passed, in which case it may be present in the env file picked up by .env\n            - SECRET_KEY: Minio secret key. Optional if `fname_minio_env` is passed, in which case it may be present in the env file picked up by .env\n            - ca_certs: optional filename pointer to ca_cert bundle for `urllib3`. Only specify if not passing `fname_minio_env`.\n            - fname_minio_env: A filename with KEY=value lines with values for keys `CA_CERTS`, `URL_PORT`, `BUCKET`.\n\n        \"\"\"\n        self._ACCESS_KEY = ACCESS_KEY\n        self._SECRET_KEY = SECRET_KEY\n        self._ca_certs = ca_certs\n        self._url_port = url_port\n\n        self._bucket = None\n        self._client = None\n\n        if fname_minio_env is not None:\n            self._process_env(fname_minio_env)\n        self._connect()\n\n    def load_obj(\n        self, path_object: str, bucket_name: Optional[str] = None\n    ) -&gt; urllib3.response.HTTPResponse:\n        \"\"\"Read an object from minio\n\n        Raises `urllib3.exceptions.HTTPError` if request is unsuccessful.\n\n        Args:\n            path_object: Object file to read from minio.\n            bucket_name: Optional bucket name, otherwise defaults to BUCKET passed\n            via minio env fniame to constructor\n\n        Returns:\n            urllib3.response.HTTPResponse\n\n        \"\"\"\n        if self._bucket is not None:\n            bucket_name = self._bucket\n        obj = self._client.get_object(bucket_name, path_object)\n        # From here, the object can be read in pandas\n        # df = pd.read_csv(obj, sep=sep, low_memory=False)\n\n        return obj\n\n    def save_obj(\n        self,\n        df,\n        path_object: str,\n        sep: Optional[str] = \",\",\n        bucket_name: Optional[str] = None,\n    ):\n        \"\"\"Save an object to minio\n\n        Args:\n            df: Pandas dataframe to be saved to Minio\n            path_object: Object filename for `df`\n            sep: Separator when saving the Pandas dataframe\n            bucket_name: Optional bucket name, otherwise defaults to BUCKET passed\n            via minio env fniame to constructor\n\n        \"\"\"\n\n        if self._bucket is not None:\n            bucket_name = self._bucket\n\n        csv_bytes = df.to_csv(index=False, sep=sep).encode(\"utf-8\")\n        csv_buffer = BytesIO(csv_bytes)\n\n        self._client.put_object(\n            bucket_name=bucket_name,\n            object_name=path_object,\n            data=csv_buffer,\n            length=len(csv_bytes),\n            content_type=\"application/csv\",\n        )\n\n        return None\n\n    def print_list_objects(\n        self,\n        bucket_name: Optional[str] = None,\n        prefix: Optional[str] = None,\n        recursive: Optional[bool] = True,\n    ):\n        \"\"\"Create a Python list of objects in a specified minio bucket\n\n        Args:\n            - bucket_name: Optional bucket name, otherwise defaults to  BUCKET passed via minio env fname to constructor\n            - prefix: Optional string used to find an object starting with &lt;prefix&gt;\n\n        Returns:\n            obj_list: List of strings containing path locations in minio bucket.\n\n        \"\"\"\n        if self._bucket is not None:\n            bucket_name = self._bucket\n\n        objs = self._client.list_objects(\n            bucket_name=bucket_name, recursive=recursive, prefix=prefix\n        )\n        obj_list = []\n        for obj in objs:\n            obj_list.append(obj.object_name)\n\n        return obj_list\n\n    def remove_obj(self, path_object: str, bucket_name: Optional[str] = None):\n        \"\"\"Remove an object from minio\n\n        Args:\n            path_object: Object file to be removed from minio\n            bucket_name: Optional bucket name, otherwise defaults to  BUCKET passed via minio env fname to constructor\n\n        \"\"\"\n        # Remove list of objects.\n        self._client.remove_object(bucket_name=bucket_name, object_name=path_object)\n        print(\"Object removed. Bucket: %s, Object: %s\" % (bucket_name, path_object))\n\n        return None\n\n    def copy_obj(\n        self,\n        source_path_object: str,\n        dest_path_object: str,\n        source_bucket: Optional[str] = None,\n        dest_bucket: Optional[str] = None,\n    ):\n        \"\"\"Copy an object in minio. \n\n        Objects can be copied across different BUCKETS. \n        Warning: objects with greater than 1GB may fail using this. \n        Instead, use `load_obj` and `save_obj` in combination.\n\n        Args:\n            source_path_object: Object file to be copied\n            dest_path_object: Object filename that `source_path_object` will be copied to\n            bucket_name: Optional bucket name, otherwise defaults to  BUCKET passed\n            via minio env fniame to constructor\n\n        Returns:\n            output: Object name and version ID of object\n        \"\"\"\n        if self._bucket is not None:\n            source_bucket = self._bucket\n            dest_bucket = self._bucket\n\n        result = self._client.copy_object(\n            dest_bucket,\n            dest_path_object,\n            CopySource(source_bucket, source_path_object),\n        )\n\n        output = [result.object_name, result.version_id]\n\n        return output\n\n    def _process_env(self, fname_minio_env):\n        dict_config = dict(dotenv_values(fname_minio_env))\n        load_dotenv(dict_config[\"MINIO_ENV\"])\n\n        env_access_key = os.getenv(\"ACCESS_KEY\")\n        if env_access_key:\n            dict_config[\"ACCESS_KEY\"] = env_access_key\n\n        env_secret_key = os.getenv(\"SECRET_KEY\")\n        if env_secret_key:\n            dict_config[\"SECRET_KEY\"] = env_secret_key\n\n        self._ACCESS_KEY = dict_config[\"ACCESS_KEY\"]\n        self._SECRET_KEY = dict_config[\"SECRET_KEY\"]\n        self._ca_certs = dict_config[\"CA_CERTS\"]\n        self._url_port = dict_config[\"URL_PORT\"]\n        self._bucket = dict_config[\"BUCKET\"]\n\n    def _connect(self):\n        # required for self-signed certs\n        httpClient = urllib3.PoolManager(\n            cert_reqs=\"CERT_REQUIRED\", ca_certs=self._ca_certs\n        )\n\n        # Create secure client with access key and secret key\n        client = Minio(\n            endpoint=self._url_port,\n            access_key=self._ACCESS_KEY,\n            secret_key=self._SECRET_KEY,\n            secure=True,\n            http_client=httpClient,\n        )\n\n        self._client = client\n</code></pre>"},{"location":"reference/#msk_cdm.minio._minio_api.MinioAPI.__init__","title":"<code>__init__(*, ACCESS_KEY=None, SECRET_KEY=None, ca_certs=None, url_port='tllihpcmind6:9000', fname_minio_env=None)</code>","text":"<p>Initialization</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>ACCESS_KEY</code> <p>Minio access key. Optional if <code>fname_minio_env</code> is passed, in which case it may be present in the env file picked up by .env</p> required <code>-</code> <code>SECRET_KEY</code> <p>Minio secret key. Optional if <code>fname_minio_env</code> is passed, in which case it may be present in the env file picked up by .env</p> required <code>-</code> <code>ca_certs</code> <p>optional filename pointer to ca_cert bundle for <code>urllib3</code>. Only specify if not passing <code>fname_minio_env</code>.</p> required <code>-</code> <code>fname_minio_env</code> <p>A filename with KEY=value lines with values for keys <code>CA_CERTS</code>, <code>URL_PORT</code>, <code>BUCKET</code>.</p> required Source code in <code>msk_cdm/minio/_minio_api.py</code> <pre><code>def __init__(\n    self,\n    *,\n    ACCESS_KEY: Optional[str] = None,\n    SECRET_KEY: Optional[str] = None,\n    ca_certs: Optional[str] = None,\n    url_port: Optional[str] = \"tllihpcmind6:9000\",\n    fname_minio_env: Optional[Union[Path, str]] = None,\n):\n    \"\"\"Initialization\n\n    Args:\n        - ACCESS_KEY: Minio access key. Optional if `fname_minio_env` is passed, in which case it may be present in the env file picked up by .env\n        - SECRET_KEY: Minio secret key. Optional if `fname_minio_env` is passed, in which case it may be present in the env file picked up by .env\n        - ca_certs: optional filename pointer to ca_cert bundle for `urllib3`. Only specify if not passing `fname_minio_env`.\n        - fname_minio_env: A filename with KEY=value lines with values for keys `CA_CERTS`, `URL_PORT`, `BUCKET`.\n\n    \"\"\"\n    self._ACCESS_KEY = ACCESS_KEY\n    self._SECRET_KEY = SECRET_KEY\n    self._ca_certs = ca_certs\n    self._url_port = url_port\n\n    self._bucket = None\n    self._client = None\n\n    if fname_minio_env is not None:\n        self._process_env(fname_minio_env)\n    self._connect()\n</code></pre>"},{"location":"reference/#msk_cdm.minio._minio_api.MinioAPI.copy_obj","title":"<code>copy_obj(source_path_object, dest_path_object, source_bucket=None, dest_bucket=None)</code>","text":"<p>Copy an object in minio. </p> <p>Objects can be copied across different BUCKETS.  Warning: objects with greater than 1GB may fail using this.  Instead, use <code>load_obj</code> and <code>save_obj</code> in combination.</p> <p>Parameters:</p> Name Type Description Default <code>source_path_object</code> <code>str</code> <p>Object file to be copied</p> required <code>dest_path_object</code> <code>str</code> <p>Object filename that <code>source_path_object</code> will be copied to</p> required <code>bucket_name</code> <p>Optional bucket name, otherwise defaults to  BUCKET passed</p> required <p>Returns:</p> Name Type Description <code>output</code> <p>Object name and version ID of object</p> Source code in <code>msk_cdm/minio/_minio_api.py</code> <pre><code>def copy_obj(\n    self,\n    source_path_object: str,\n    dest_path_object: str,\n    source_bucket: Optional[str] = None,\n    dest_bucket: Optional[str] = None,\n):\n    \"\"\"Copy an object in minio. \n\n    Objects can be copied across different BUCKETS. \n    Warning: objects with greater than 1GB may fail using this. \n    Instead, use `load_obj` and `save_obj` in combination.\n\n    Args:\n        source_path_object: Object file to be copied\n        dest_path_object: Object filename that `source_path_object` will be copied to\n        bucket_name: Optional bucket name, otherwise defaults to  BUCKET passed\n        via minio env fniame to constructor\n\n    Returns:\n        output: Object name and version ID of object\n    \"\"\"\n    if self._bucket is not None:\n        source_bucket = self._bucket\n        dest_bucket = self._bucket\n\n    result = self._client.copy_object(\n        dest_bucket,\n        dest_path_object,\n        CopySource(source_bucket, source_path_object),\n    )\n\n    output = [result.object_name, result.version_id]\n\n    return output\n</code></pre>"},{"location":"reference/#msk_cdm.minio._minio_api.MinioAPI.load_obj","title":"<code>load_obj(path_object, bucket_name=None)</code>","text":"<p>Read an object from minio</p> <p>Raises <code>urllib3.exceptions.HTTPError</code> if request is unsuccessful.</p> <p>Parameters:</p> Name Type Description Default <code>path_object</code> <code>str</code> <p>Object file to read from minio.</p> required <code>bucket_name</code> <code>Optional[str]</code> <p>Optional bucket name, otherwise defaults to BUCKET passed</p> <code>None</code> <p>Returns:</p> Type Description <code>HTTPResponse</code> <p>urllib3.response.HTTPResponse</p> Source code in <code>msk_cdm/minio/_minio_api.py</code> <pre><code>def load_obj(\n    self, path_object: str, bucket_name: Optional[str] = None\n) -&gt; urllib3.response.HTTPResponse:\n    \"\"\"Read an object from minio\n\n    Raises `urllib3.exceptions.HTTPError` if request is unsuccessful.\n\n    Args:\n        path_object: Object file to read from minio.\n        bucket_name: Optional bucket name, otherwise defaults to BUCKET passed\n        via minio env fniame to constructor\n\n    Returns:\n        urllib3.response.HTTPResponse\n\n    \"\"\"\n    if self._bucket is not None:\n        bucket_name = self._bucket\n    obj = self._client.get_object(bucket_name, path_object)\n    # From here, the object can be read in pandas\n    # df = pd.read_csv(obj, sep=sep, low_memory=False)\n\n    return obj\n</code></pre>"},{"location":"reference/#msk_cdm.minio._minio_api.MinioAPI.print_list_objects","title":"<code>print_list_objects(bucket_name=None, prefix=None, recursive=True)</code>","text":"<p>Create a Python list of objects in a specified minio bucket</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>bucket_name</code> <p>Optional bucket name, otherwise defaults to  BUCKET passed via minio env fname to constructor</p> required <code>-</code> <code>prefix</code> <p>Optional string used to find an object starting with  required <p>Returns:</p> Name Type Description <code>obj_list</code> <p>List of strings containing path locations in minio bucket.</p> Source code in <code>msk_cdm/minio/_minio_api.py</code> <pre><code>def print_list_objects(\n    self,\n    bucket_name: Optional[str] = None,\n    prefix: Optional[str] = None,\n    recursive: Optional[bool] = True,\n):\n    \"\"\"Create a Python list of objects in a specified minio bucket\n\n    Args:\n        - bucket_name: Optional bucket name, otherwise defaults to  BUCKET passed via minio env fname to constructor\n        - prefix: Optional string used to find an object starting with &lt;prefix&gt;\n\n    Returns:\n        obj_list: List of strings containing path locations in minio bucket.\n\n    \"\"\"\n    if self._bucket is not None:\n        bucket_name = self._bucket\n\n    objs = self._client.list_objects(\n        bucket_name=bucket_name, recursive=recursive, prefix=prefix\n    )\n    obj_list = []\n    for obj in objs:\n        obj_list.append(obj.object_name)\n\n    return obj_list\n</code></pre>"},{"location":"reference/#msk_cdm.minio._minio_api.MinioAPI.remove_obj","title":"<code>remove_obj(path_object, bucket_name=None)</code>","text":"<p>Remove an object from minio</p> <p>Parameters:</p> Name Type Description Default <code>path_object</code> <code>str</code> <p>Object file to be removed from minio</p> required <code>bucket_name</code> <code>Optional[str]</code> <p>Optional bucket name, otherwise defaults to  BUCKET passed via minio env fname to constructor</p> <code>None</code> Source code in <code>msk_cdm/minio/_minio_api.py</code> <pre><code>def remove_obj(self, path_object: str, bucket_name: Optional[str] = None):\n    \"\"\"Remove an object from minio\n\n    Args:\n        path_object: Object file to be removed from minio\n        bucket_name: Optional bucket name, otherwise defaults to  BUCKET passed via minio env fname to constructor\n\n    \"\"\"\n    # Remove list of objects.\n    self._client.remove_object(bucket_name=bucket_name, object_name=path_object)\n    print(\"Object removed. Bucket: %s, Object: %s\" % (bucket_name, path_object))\n\n    return None\n</code></pre>"},{"location":"reference/#msk_cdm.minio._minio_api.MinioAPI.save_obj","title":"<code>save_obj(df, path_object, sep=',', bucket_name=None)</code>","text":"<p>Save an object to minio</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>Pandas dataframe to be saved to Minio</p> required <code>path_object</code> <code>str</code> <p>Object filename for <code>df</code></p> required <code>sep</code> <code>Optional[str]</code> <p>Separator when saving the Pandas dataframe</p> <code>','</code> <code>bucket_name</code> <code>Optional[str]</code> <p>Optional bucket name, otherwise defaults to BUCKET passed</p> <code>None</code> Source code in <code>msk_cdm/minio/_minio_api.py</code> <pre><code>def save_obj(\n    self,\n    df,\n    path_object: str,\n    sep: Optional[str] = \",\",\n    bucket_name: Optional[str] = None,\n):\n    \"\"\"Save an object to minio\n\n    Args:\n        df: Pandas dataframe to be saved to Minio\n        path_object: Object filename for `df`\n        sep: Separator when saving the Pandas dataframe\n        bucket_name: Optional bucket name, otherwise defaults to BUCKET passed\n        via minio env fniame to constructor\n\n    \"\"\"\n\n    if self._bucket is not None:\n        bucket_name = self._bucket\n\n    csv_bytes = df.to_csv(index=False, sep=sep).encode(\"utf-8\")\n    csv_buffer = BytesIO(csv_bytes)\n\n    self._client.put_object(\n        bucket_name=bucket_name,\n        object_name=path_object,\n        data=csv_buffer,\n        length=len(csv_bytes),\n        content_type=\"application/csv\",\n    )\n\n    return None\n</code></pre>"}]}