{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to CDM Documentation!","text":""},{"location":"reference/","title":"Minio","text":""},{"location":"reference/#msk_cdm.minio._minio_api.MinioAPI","title":"<code>MinioAPI</code>","text":"<p>             Bases: <code>object</code></p> <p>Object to simplify reading/writing to/from Minio.</p> Source code in <code>msk_cdm/minio/_minio_api.py</code> <pre><code>class MinioAPI(object):\n    \"\"\"Object to simplify reading/writing to/from Minio.\"\"\"\n\n    def __init__(\n        self,\n        *,\n        ACCESS_KEY: Optional[str] = None,\n        SECRET_KEY: Optional[str] = None,\n        ca_certs: Optional[str] = None,\n        url_port: Optional[str] = \"tllihpcmind6:9000\",\n        fname_minio_env: Optional[Union[Path, str]] = None,\n    ):\n        \"\"\"Initialization\n\n        Args:\n            - ACCESS_KEY: Minio access key. Optional if `fname_minio_env` is passed, in which case it may be present in the env file picked up by .env\n            - SECRET_KEY: Minio secret key. Optional if `fname_minio_env` is passed, in which case it may be present in the env file picked up by .env\n            - ca_certs: optional filename pointer to ca_cert bundle for `urllib3`. Only specify if not passing `fname_minio_env`.\n            - fname_minio_env: A filename with KEY=value lines with values for keys `CA_CERTS`, `URL_PORT`, `BUCKET`.\n\n        \"\"\"\n        self._ACCESS_KEY = ACCESS_KEY\n        self._SECRET_KEY = SECRET_KEY\n        self._ca_certs = ca_certs\n        self._url_port = url_port\n\n        self._bucket = None\n        self._client = None\n\n        if fname_minio_env is not None:\n            self._process_env(fname_minio_env)\n        self._connect()\n\n    def load_obj(\n        self, path_object: str, bucket_name: Optional[str] = None\n    ) -&gt; urllib3.response.HTTPResponse:\n        \"\"\"Read an object from minio\n\n        Raises `urllib3.exceptions.HTTPError` if request is unsuccessful.\n\n        Args:\n            path_object: Object file to read from minio.\n            bucket_name: Optional bucket name, otherwise defaults to BUCKET passed\n            via minio env fniame to constructor\n\n        Returns:\n            urllib3.response.HTTPResponse\n\n        \"\"\"\n        if self._bucket is not None:\n            bucket_name = self._bucket\n        obj = self._client.get_object(bucket_name, path_object)\n        # From here, the object can be read in pandas\n        # df = pd.read_csv(obj, sep=sep, low_memory=False)\n\n        return obj\n\n    def save_obj(\n        self,\n        df,\n        path_object: str,\n        sep: Optional[str] = \",\",\n        bucket_name: Optional[str] = None,\n    ):\n        \"\"\"Save an object to minio\n\n        Args:\n            df: Pandas dataframe to be saved to Minio\n            path_object: Object filename for `df`\n            sep: Separator when saving the Pandas dataframe\n            bucket_name: Optional bucket name, otherwise defaults to BUCKET passed\n            via minio env fniame to constructor\n\n        \"\"\"\n\n        if self._bucket is not None:\n            bucket_name = self._bucket\n\n        csv_bytes = df.to_csv(index=False, sep=sep).encode(\"utf-8\")\n        csv_buffer = BytesIO(csv_bytes)\n\n        self._client.put_object(\n            bucket_name=bucket_name,\n            object_name=path_object,\n            data=csv_buffer,\n            length=len(csv_bytes),\n            content_type=\"application/csv\",\n        )\n\n        return None\n\n    def print_list_objects(\n        self,\n        bucket_name: Optional[str] = None,\n        prefix: Optional[str] = None,\n        recursive: Optional[bool] = True,\n    ):\n        \"\"\"Create a Python list of objects in a specified minio bucket\n\n        Args:\n            - bucket_name: Optional bucket name, otherwise defaults to  BUCKET passed via minio env fname to constructor\n            - prefix: Optional string used to find an object starting with &lt;prefix&gt;\n\n        Returns:\n            obj_list: List of strings containing path locations in minio bucket.\n\n        \"\"\"\n        if self._bucket is not None:\n            bucket_name = self._bucket\n\n        objs = self._client.list_objects(\n            bucket_name=bucket_name, recursive=recursive, prefix=prefix\n        )\n        obj_list = []\n        for obj in objs:\n            obj_list.append(obj.object_name)\n\n        return obj_list\n\n    def remove_obj(self, path_object: str, bucket_name: Optional[str] = None):\n        \"\"\"Remove an object from minio\n\n        Args:\n            path_object: Object file to be removed from minio\n            bucket_name: Optional bucket name, otherwise defaults to  BUCKET passed via minio env fname to constructor\n\n        \"\"\"\n        # Remove list of objects.\n        self._client.remove_object(bucket_name=bucket_name, object_name=path_object)\n        print(\"Object removed. Bucket: %s, Object: %s\" % (bucket_name, path_object))\n\n        return None\n\n    def copy_obj(\n        self,\n        source_path_object: str,\n        dest_path_object: str,\n        source_bucket: Optional[str] = None,\n        dest_bucket: Optional[str] = None,\n    ):\n        \"\"\"Copy an object in minio. \n\n        Objects can be copied across different BUCKETS. \n        Warning: objects with greater than 1GB may fail using this. \n        Instead, use `load_obj` and `save_obj` in combination.\n\n        Args:\n            source_path_object: Object file to be copied\n            dest_path_object: Object filename that `source_path_object` will be copied to\n            bucket_name: Optional bucket name, otherwise defaults to  BUCKET passed\n            via minio env fniame to constructor\n\n        Returns:\n            output: Object name and version ID of object\n        \"\"\"\n        if self._bucket is not None:\n            source_bucket = self._bucket\n            dest_bucket = self._bucket\n\n        result = self._client.copy_object(\n            dest_bucket,\n            dest_path_object,\n            CopySource(source_bucket, source_path_object),\n        )\n\n        output = [result.object_name, result.version_id]\n\n        return output\n\n    def _process_env(self, fname_minio_env):\n        dict_config = dict(dotenv_values(fname_minio_env))\n        load_dotenv(dict_config[\"MINIO_ENV\"])\n\n        env_access_key = os.getenv(\"ACCESS_KEY\")\n        if env_access_key:\n            dict_config[\"ACCESS_KEY\"] = env_access_key\n\n        env_secret_key = os.getenv(\"SECRET_KEY\")\n        if env_secret_key:\n            dict_config[\"SECRET_KEY\"] = env_secret_key\n\n        self._ACCESS_KEY = dict_config[\"ACCESS_KEY\"]\n        self._SECRET_KEY = dict_config[\"SECRET_KEY\"]\n        self._ca_certs = dict_config[\"CA_CERTS\"]\n        self._url_port = dict_config[\"URL_PORT\"]\n        self._bucket = dict_config[\"BUCKET\"]\n\n    def _connect(self):\n        # required for self-signed certs\n        httpClient = urllib3.PoolManager(\n            cert_reqs=\"CERT_REQUIRED\", ca_certs=self._ca_certs\n        )\n\n        # Create secure client with access key and secret key\n        client = Minio(\n            endpoint=self._url_port,\n            access_key=self._ACCESS_KEY,\n            secret_key=self._SECRET_KEY,\n            secure=True,\n            http_client=httpClient,\n        )\n\n        self._client = client\n</code></pre>"},{"location":"reference/#msk_cdm.minio._minio_api.MinioAPI.__init__","title":"<code>__init__(*, ACCESS_KEY=None, SECRET_KEY=None, ca_certs=None, url_port='tllihpcmind6:9000', fname_minio_env=None)</code>","text":"<p>Initialization</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>ACCESS_KEY</code> <p>Minio access key. Optional if <code>fname_minio_env</code> is passed, in which case it may be present in the env file picked up by .env</p> required <code>-</code> <code>SECRET_KEY</code> <p>Minio secret key. Optional if <code>fname_minio_env</code> is passed, in which case it may be present in the env file picked up by .env</p> required <code>-</code> <code>ca_certs</code> <p>optional filename pointer to ca_cert bundle for <code>urllib3</code>. Only specify if not passing <code>fname_minio_env</code>.</p> required <code>-</code> <code>fname_minio_env</code> <p>A filename with KEY=value lines with values for keys <code>CA_CERTS</code>, <code>URL_PORT</code>, <code>BUCKET</code>.</p> required Source code in <code>msk_cdm/minio/_minio_api.py</code> <pre><code>def __init__(\n    self,\n    *,\n    ACCESS_KEY: Optional[str] = None,\n    SECRET_KEY: Optional[str] = None,\n    ca_certs: Optional[str] = None,\n    url_port: Optional[str] = \"tllihpcmind6:9000\",\n    fname_minio_env: Optional[Union[Path, str]] = None,\n):\n    \"\"\"Initialization\n\n    Args:\n        - ACCESS_KEY: Minio access key. Optional if `fname_minio_env` is passed, in which case it may be present in the env file picked up by .env\n        - SECRET_KEY: Minio secret key. Optional if `fname_minio_env` is passed, in which case it may be present in the env file picked up by .env\n        - ca_certs: optional filename pointer to ca_cert bundle for `urllib3`. Only specify if not passing `fname_minio_env`.\n        - fname_minio_env: A filename with KEY=value lines with values for keys `CA_CERTS`, `URL_PORT`, `BUCKET`.\n\n    \"\"\"\n    self._ACCESS_KEY = ACCESS_KEY\n    self._SECRET_KEY = SECRET_KEY\n    self._ca_certs = ca_certs\n    self._url_port = url_port\n\n    self._bucket = None\n    self._client = None\n\n    if fname_minio_env is not None:\n        self._process_env(fname_minio_env)\n    self._connect()\n</code></pre>"},{"location":"reference/#msk_cdm.minio._minio_api.MinioAPI.copy_obj","title":"<code>copy_obj(source_path_object, dest_path_object, source_bucket=None, dest_bucket=None)</code>","text":"<p>Copy an object in minio. </p> <p>Objects can be copied across different BUCKETS.  Warning: objects with greater than 1GB may fail using this.  Instead, use <code>load_obj</code> and <code>save_obj</code> in combination.</p> <p>Parameters:</p> Name Type Description Default <code>source_path_object</code> <code>str</code> <p>Object file to be copied</p> required <code>dest_path_object</code> <code>str</code> <p>Object filename that <code>source_path_object</code> will be copied to</p> required <code>bucket_name</code> <p>Optional bucket name, otherwise defaults to  BUCKET passed</p> required <p>Returns:</p> Name Type Description <code>output</code> <p>Object name and version ID of object</p> Source code in <code>msk_cdm/minio/_minio_api.py</code> <pre><code>def copy_obj(\n    self,\n    source_path_object: str,\n    dest_path_object: str,\n    source_bucket: Optional[str] = None,\n    dest_bucket: Optional[str] = None,\n):\n    \"\"\"Copy an object in minio. \n\n    Objects can be copied across different BUCKETS. \n    Warning: objects with greater than 1GB may fail using this. \n    Instead, use `load_obj` and `save_obj` in combination.\n\n    Args:\n        source_path_object: Object file to be copied\n        dest_path_object: Object filename that `source_path_object` will be copied to\n        bucket_name: Optional bucket name, otherwise defaults to  BUCKET passed\n        via minio env fniame to constructor\n\n    Returns:\n        output: Object name and version ID of object\n    \"\"\"\n    if self._bucket is not None:\n        source_bucket = self._bucket\n        dest_bucket = self._bucket\n\n    result = self._client.copy_object(\n        dest_bucket,\n        dest_path_object,\n        CopySource(source_bucket, source_path_object),\n    )\n\n    output = [result.object_name, result.version_id]\n\n    return output\n</code></pre>"},{"location":"reference/#msk_cdm.minio._minio_api.MinioAPI.load_obj","title":"<code>load_obj(path_object, bucket_name=None)</code>","text":"<p>Read an object from minio</p> <p>Raises <code>urllib3.exceptions.HTTPError</code> if request is unsuccessful.</p> <p>Parameters:</p> Name Type Description Default <code>path_object</code> <code>str</code> <p>Object file to read from minio.</p> required <code>bucket_name</code> <code>Optional[str]</code> <p>Optional bucket name, otherwise defaults to BUCKET passed</p> <code>None</code> <p>Returns:</p> Type Description <code>HTTPResponse</code> <p>urllib3.response.HTTPResponse</p> Source code in <code>msk_cdm/minio/_minio_api.py</code> <pre><code>def load_obj(\n    self, path_object: str, bucket_name: Optional[str] = None\n) -&gt; urllib3.response.HTTPResponse:\n    \"\"\"Read an object from minio\n\n    Raises `urllib3.exceptions.HTTPError` if request is unsuccessful.\n\n    Args:\n        path_object: Object file to read from minio.\n        bucket_name: Optional bucket name, otherwise defaults to BUCKET passed\n        via minio env fniame to constructor\n\n    Returns:\n        urllib3.response.HTTPResponse\n\n    \"\"\"\n    if self._bucket is not None:\n        bucket_name = self._bucket\n    obj = self._client.get_object(bucket_name, path_object)\n    # From here, the object can be read in pandas\n    # df = pd.read_csv(obj, sep=sep, low_memory=False)\n\n    return obj\n</code></pre>"},{"location":"reference/#msk_cdm.minio._minio_api.MinioAPI.print_list_objects","title":"<code>print_list_objects(bucket_name=None, prefix=None, recursive=True)</code>","text":"<p>Create a Python list of objects in a specified minio bucket</p> <p>Parameters:</p> Name Type Description Default <code>-</code> <code>bucket_name</code> <p>Optional bucket name, otherwise defaults to  BUCKET passed via minio env fname to constructor</p> required <code>-</code> <code>prefix</code> <p>Optional string used to find an object starting with  required <p>Returns:</p> Name Type Description <code>obj_list</code> <p>List of strings containing path locations in minio bucket.</p> Source code in <code>msk_cdm/minio/_minio_api.py</code> <pre><code>def print_list_objects(\n    self,\n    bucket_name: Optional[str] = None,\n    prefix: Optional[str] = None,\n    recursive: Optional[bool] = True,\n):\n    \"\"\"Create a Python list of objects in a specified minio bucket\n\n    Args:\n        - bucket_name: Optional bucket name, otherwise defaults to  BUCKET passed via minio env fname to constructor\n        - prefix: Optional string used to find an object starting with &lt;prefix&gt;\n\n    Returns:\n        obj_list: List of strings containing path locations in minio bucket.\n\n    \"\"\"\n    if self._bucket is not None:\n        bucket_name = self._bucket\n\n    objs = self._client.list_objects(\n        bucket_name=bucket_name, recursive=recursive, prefix=prefix\n    )\n    obj_list = []\n    for obj in objs:\n        obj_list.append(obj.object_name)\n\n    return obj_list\n</code></pre>"},{"location":"reference/#msk_cdm.minio._minio_api.MinioAPI.remove_obj","title":"<code>remove_obj(path_object, bucket_name=None)</code>","text":"<p>Remove an object from minio</p> <p>Parameters:</p> Name Type Description Default <code>path_object</code> <code>str</code> <p>Object file to be removed from minio</p> required <code>bucket_name</code> <code>Optional[str]</code> <p>Optional bucket name, otherwise defaults to  BUCKET passed via minio env fname to constructor</p> <code>None</code> Source code in <code>msk_cdm/minio/_minio_api.py</code> <pre><code>def remove_obj(self, path_object: str, bucket_name: Optional[str] = None):\n    \"\"\"Remove an object from minio\n\n    Args:\n        path_object: Object file to be removed from minio\n        bucket_name: Optional bucket name, otherwise defaults to  BUCKET passed via minio env fname to constructor\n\n    \"\"\"\n    # Remove list of objects.\n    self._client.remove_object(bucket_name=bucket_name, object_name=path_object)\n    print(\"Object removed. Bucket: %s, Object: %s\" % (bucket_name, path_object))\n\n    return None\n</code></pre>"},{"location":"reference/#msk_cdm.minio._minio_api.MinioAPI.save_obj","title":"<code>save_obj(df, path_object, sep=',', bucket_name=None)</code>","text":"<p>Save an object to minio</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <p>Pandas dataframe to be saved to Minio</p> required <code>path_object</code> <code>str</code> <p>Object filename for <code>df</code></p> required <code>sep</code> <code>Optional[str]</code> <p>Separator when saving the Pandas dataframe</p> <code>','</code> <code>bucket_name</code> <code>Optional[str]</code> <p>Optional bucket name, otherwise defaults to BUCKET passed</p> <code>None</code> Source code in <code>msk_cdm/minio/_minio_api.py</code> <pre><code>def save_obj(\n    self,\n    df,\n    path_object: str,\n    sep: Optional[str] = \",\",\n    bucket_name: Optional[str] = None,\n):\n    \"\"\"Save an object to minio\n\n    Args:\n        df: Pandas dataframe to be saved to Minio\n        path_object: Object filename for `df`\n        sep: Separator when saving the Pandas dataframe\n        bucket_name: Optional bucket name, otherwise defaults to BUCKET passed\n        via minio env fniame to constructor\n\n    \"\"\"\n\n    if self._bucket is not None:\n        bucket_name = self._bucket\n\n    csv_bytes = df.to_csv(index=False, sep=sep).encode(\"utf-8\")\n    csv_buffer = BytesIO(csv_bytes)\n\n    self._client.put_object(\n        bucket_name=bucket_name,\n        object_name=path_object,\n        data=csv_buffer,\n        length=len(csv_bytes),\n        content_type=\"application/csv\",\n    )\n\n    return None\n</code></pre>"},{"location":"reference/dremio/","title":"Dremio","text":""},{"location":"reference/dremio/#msk_cdm.dremio._dremio_api.DremioAPI","title":"<code>DremioAPI</code>","text":"<p>             Bases: <code>object</code></p> <p>Object to simplify reading from Dremio (CDSI's SQL engine).</p> Source code in <code>msk_cdm/dremio/_dremio_api.py</code> <pre><code>class DremioAPI(object):\n    \"\"\"Object to simplify reading from Dremio (CDSI's SQL engine).\"\"\"\n\n    def __init__(\n        self, \n        *,\n        fname_env: str, \n        env_key_user: Optional[str] = 'USER', \n        env_key_pw: Optional[str] = 'PW',\n        scheme: Optional[str] = \"grpc+tcp\",\n        hostname: Optional[str] = \"tlvidreamcord1\",\n        flightport: Optional[int] = 32010\n    ):\n        \"\"\"Initialization\n\n        Args:\n            fname_env: Environment file with username and pw\n            env_key_user: Key term to identify the username in fname_env\n            env_key_pw: Key term to identify the password in fname_env\n            scheme: The connection scheme used\n            hostname: Server hostname\n            flightport: Port number\n\n        \"\"\"\n\n        self._df = None\n        self._scheme = scheme\n        self._hostname = hostname\n        self._flightport = flightport\n\n        load_dotenv(fname_env)\n        self._authenticate(\n            user=os.getenv(env_key_user), \n            pw=os.getenv(env_key_pw)\n        )\n\n    def return_data(self):\n        \"\"\"Return data queried from Dremio in a Pandas dataframe\n\n        Returns:\n            df\n\n        \"\"\"\n        df = self._df\n\n        return df\n\n    def _authenticate(self, user, pw):\n        scheme = self._scheme\n        hostname = self._hostname\n        flightport = self._flightport\n        connection_args = {}\n        # Two WLM settings can be provided upon initial authentication \n        # with the Dremio Server Flight Endpoint:\n        # - routing-tag\n        # - routing queue\n        initial_options = flight.FlightCallOptions(headers=[\n            (b'routing-tag', b'test-routing-tag'),\n            (b'routing-queue', b'Low Cost User Queries')\n        ])\n        client_auth_middleware = DremioClientAuthMiddlewareFactory()\n        client = flight.FlightClient(f\"{scheme}://{hostname}:{flightport}\", middleware=[client_auth_middleware], **connection_args)\n        bearer_token = client.authenticate_basic_token(\n            user, \n            pw, \n            initial_options\n        )\n        print('[INFO] Authentication was successful')\n\n        self._client = client\n        self._bearer_token = bearer_token\n\n    def query_data(self, sql):\n        \"\"\"Query Dremio with SQL string\n\n        Args:\n            sql: SQL string used to query Dremio\n\n        Returns:\n            df_output\n\n        \"\"\"\n        client = self._client\n        bearer_token = self._bearer_token\n        # Get table from our dicom segments\n        flight_desc = flight.FlightDescriptor.for_command(sql)\n        options = flight.FlightCallOptions(headers=[bearer_token])\n        schema = client.get_schema(flight_desc, options)\n\n        flight_info = client.get_flight_info(\n            flight.FlightDescriptor.for_command(sql),\n            options\n        )\n        reader = client.do_get(\n            flight_info.endpoints[0].ticket, \n            options\n        )\n\n        df_output = reader.read_pandas()\n\n        self._df = df_output\n\n        return df_output\n</code></pre>"},{"location":"reference/dremio/#msk_cdm.dremio._dremio_api.DremioAPI.__init__","title":"<code>__init__(*, fname_env, env_key_user='USER', env_key_pw='PW', scheme='grpc+tcp', hostname='tlvidreamcord1', flightport=32010)</code>","text":"<p>Initialization</p> <p>Parameters:</p> Name Type Description Default <code>fname_env</code> <code>str</code> <p>Environment file with username and pw</p> required <code>env_key_user</code> <code>Optional[str]</code> <p>Key term to identify the username in fname_env</p> <code>'USER'</code> <code>env_key_pw</code> <code>Optional[str]</code> <p>Key term to identify the password in fname_env</p> <code>'PW'</code> <code>scheme</code> <code>Optional[str]</code> <p>The connection scheme used</p> <code>'grpc+tcp'</code> <code>hostname</code> <code>Optional[str]</code> <p>Server hostname</p> <code>'tlvidreamcord1'</code> <code>flightport</code> <code>Optional[int]</code> <p>Port number</p> <code>32010</code> Source code in <code>msk_cdm/dremio/_dremio_api.py</code> <pre><code>def __init__(\n    self, \n    *,\n    fname_env: str, \n    env_key_user: Optional[str] = 'USER', \n    env_key_pw: Optional[str] = 'PW',\n    scheme: Optional[str] = \"grpc+tcp\",\n    hostname: Optional[str] = \"tlvidreamcord1\",\n    flightport: Optional[int] = 32010\n):\n    \"\"\"Initialization\n\n    Args:\n        fname_env: Environment file with username and pw\n        env_key_user: Key term to identify the username in fname_env\n        env_key_pw: Key term to identify the password in fname_env\n        scheme: The connection scheme used\n        hostname: Server hostname\n        flightport: Port number\n\n    \"\"\"\n\n    self._df = None\n    self._scheme = scheme\n    self._hostname = hostname\n    self._flightport = flightport\n\n    load_dotenv(fname_env)\n    self._authenticate(\n        user=os.getenv(env_key_user), \n        pw=os.getenv(env_key_pw)\n    )\n</code></pre>"},{"location":"reference/dremio/#msk_cdm.dremio._dremio_api.DremioAPI.query_data","title":"<code>query_data(sql)</code>","text":"<p>Query Dremio with SQL string</p> <p>Parameters:</p> Name Type Description Default <code>sql</code> <p>SQL string used to query Dremio</p> required <p>Returns:</p> Type Description <p>df_output</p> Source code in <code>msk_cdm/dremio/_dremio_api.py</code> <pre><code>def query_data(self, sql):\n    \"\"\"Query Dremio with SQL string\n\n    Args:\n        sql: SQL string used to query Dremio\n\n    Returns:\n        df_output\n\n    \"\"\"\n    client = self._client\n    bearer_token = self._bearer_token\n    # Get table from our dicom segments\n    flight_desc = flight.FlightDescriptor.for_command(sql)\n    options = flight.FlightCallOptions(headers=[bearer_token])\n    schema = client.get_schema(flight_desc, options)\n\n    flight_info = client.get_flight_info(\n        flight.FlightDescriptor.for_command(sql),\n        options\n    )\n    reader = client.do_get(\n        flight_info.endpoints[0].ticket, \n        options\n    )\n\n    df_output = reader.read_pandas()\n\n    self._df = df_output\n\n    return df_output\n</code></pre>"},{"location":"reference/dremio/#msk_cdm.dremio._dremio_api.DremioAPI.return_data","title":"<code>return_data()</code>","text":"<p>Return data queried from Dremio in a Pandas dataframe</p> <p>Returns:</p> Type Description <p>df</p> Source code in <code>msk_cdm/dremio/_dremio_api.py</code> <pre><code>def return_data(self):\n    \"\"\"Return data queried from Dremio in a Pandas dataframe\n\n    Returns:\n        df\n\n    \"\"\"\n    df = self._df\n\n    return df\n</code></pre>"},{"location":"reference/dremio/#msk_cdm.dremio._dremio_api.DremioClientAuthMiddleware","title":"<code>DremioClientAuthMiddleware</code>","text":"<p>             Bases: <code>ClientMiddleware</code></p> <p>A ClientMiddleware that extracts the bearer token from  the authorization header returned by the Dremio  Flight Server Endpoint. Parameters</p> <p>factory : ClientHeaderAuthMiddlewareFactory     The factory to set call credentials if an     authorization header with bearer token is     returned by the Dremio server.</p> Source code in <code>msk_cdm/dremio/_dremio_api.py</code> <pre><code>class DremioClientAuthMiddleware(flight.ClientMiddleware):\n    \"\"\"\n    A ClientMiddleware that extracts the bearer token from \n    the authorization header returned by the Dremio \n    Flight Server Endpoint.\n    Parameters\n    ----------\n    factory : ClientHeaderAuthMiddlewareFactory\n        The factory to set call credentials if an\n        authorization header with bearer token is\n        returned by the Dremio server.\n    \"\"\"\n\n    def __init__(self, factory):\n        self.factory = factory\n\n    def received_headers(self, headers):\n        auth_header_key = 'authorization'\n        authorization_header = []\n        for key in headers:\n            if key.lower() == auth_header_key: authorization_header = headers.get(auth_header_key)\n        self.factory.set_call_credential([\n            b'authorization', authorization_header[0].encode(\"utf-8\")])\n</code></pre>"},{"location":"reference/dremio/#msk_cdm.dremio._dremio_api.DremioClientAuthMiddlewareFactory","title":"<code>DremioClientAuthMiddlewareFactory</code>","text":"<p>             Bases: <code>ClientMiddlewareFactory</code></p> <p>A factory that creates DremioClientAuthMiddleware(s).</p> Source code in <code>msk_cdm/dremio/_dremio_api.py</code> <pre><code>class DremioClientAuthMiddlewareFactory(flight.ClientMiddlewareFactory):\n    \"\"\"A factory that creates DremioClientAuthMiddleware(s).\"\"\"\n\n    def __init__(self):\n        self.call_credential = []\n\n    def start_call(self, info):\n        return DremioClientAuthMiddleware(self)\n\n    def set_call_credential(self, call_credential):\n        self.call_credential = call_credential\n</code></pre>"}]}